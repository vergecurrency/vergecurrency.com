var PARENT_DIRNAME, PARSER_SCHEMA, YAML_EXT, basename, co, dirname, dump, extname, fulfill, isAbsolute, isNumber, join, junk, load, normalizeOptions, normalizePath, normalizePathSync, parse, read, readFile, readFileSync, readSync, readYamlFile, readdir, readdirSync, ref, ref1, ref2, ref3, resolve, write, writeFile, writeFileSync, writeSync, writeYamlFile, yaml,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

isNumber = require("util").isNumber;

co = require("co");

junk = require("junk");

ref = require("fs"), readFileSync = ref.readFileSync, writeFileSync = ref.writeFileSync, readdirSync = ref.readdirSync;

ref1 = require("promise-fs"), readFile = ref1.readFile, writeFile = ref1.writeFile, readdir = ref1.readdir;

ref2 = require("path"), dirname = ref2.dirname, basename = ref2.basename, extname = ref2.extname, isAbsolute = ref2.isAbsolute, join = ref2.join, resolve = ref2.resolve;

ref3 = yaml = require("js-yaml"), parse = ref3.parse, load = ref3.load, dump = ref3.dump;

PARSER_SCHEMA = {
  defaultSafe: yaml.DEFAULT_SAFE_SCHEMA,
  defaultFull: yaml.DEFAULT_FULL_SCHEMA,
  failsafe: yaml.FAILSAFE_SCHEMA,
  json: yaml.JSON_SCHEMA,
  core: yaml.CORE_SCHEMA
};

YAML_EXT = [".yaml", ".yml"];

PARENT_DIRNAME = dirname(module.parent.filename);

delete require.cache[__filename];


/*
 * Fulfill a promised function as callback-style function if it given
 *   or return a promise
 *
 * @param function cb
 * @param fn â€“ promised function, wrapped into clojure (see yaml.read method)
 *
 * @return Promise|undefined
 */

fulfill = function(cb, fn) {
  var onFulfilled, onRejected, promise;
  if (typeof cb !== "function") {
    return fn();
  }
  onFulfilled = function(res) {
    return cb(null, res);
  };
  onRejected = function(err) {
    return cb(err);
  };
  promise = fn();
  promise.then(onFulfilled, onRejected);
};


/*
 * Normalize path to YAML file
 * 
 * @param string sPath Path to YAML file
 *
 * @api private
 */

normalizePath = function*(filename) {
  var __base, __ext, base, dir, file, files, i, len;
  if (!isAbsolute(filename)) {
    filename = resolve(PARENT_DIRNAME, filename);
  }
  base = basename(filename);
  dir = dirname(filename);
  files = (yield readdir(dir));
  for (i = 0, len = files.length; i < len; i++) {
    file = files[i];
    if (!(junk.not(file))) {
      continue;
    }
    __ext = extname(file);
    __base = basename(file, __ext);
    if (base === __base && indexOf.call(YAML_EXT, __ext) >= 0) {
      return join(dir, file);
    }
  }
  return filename;
};


/*
 * Normalize path to YAML file (Synchronously)
 * 
 * @param string sPath Path to YAML file
 *
 * @api private
 */

normalizePathSync = function(filename) {
  var __base, __ext, base, dir, file, files, i, len;
  if (!isAbsolute(filename)) {
    filename = resolve(PARENT_DIRNAME, filename);
  }
  base = basename(filename);
  dir = dirname(filename);
  files = readdirSync(dir);
  for (i = 0, len = files.length; i < len; i++) {
    file = files[i];
    if (!(junk.not(file))) {
      continue;
    }
    __ext = extname(file);
    __base = basename(file, __ext);
    if (base === __base && indexOf.call(YAML_EXT, __ext) >= 0) {
      return join(dir, file);
    }
  }
  return filename;
};


/*
 * Normalize options
 * 
 * @param string|object options
 * 
 * @return object
 *
 * @api private
 */

normalizeOptions = function(options) {
  if (options == null) {
    return {
      encoding: "utf8",
      schema: PARSER_SCHEMA.defaultSafe
    };
  }
  options = (function() {
    switch (typeof options) {
      case "string":
        return {
          encoding: options,
          schema: PARSER_SCHEMA.defaultSafe
        };
      case "object":
        options.encoding || (options.encoding = "utf8");
        options.schema || (options.schema = PARSER_SCHEMA.defaultSafe);
        return options;
    }
  })();
  return options;
};


/*
 * Read YAML file with Promise
 *
 * @param int|string filename - File descriptor or path
 * @param null|object options
 *
 * @return Promise
 *
 * @api private
 */

readYamlFile = co.wrap(function*(filename, options) {
  var content;
  if (options == null) {
    options = {};
  }
  if (!isNumber(filename)) {
    filename = (yield normalizePath(filename));
  }
  options = normalizeOptions(options);
  content = (yield readFile(filename, options.encoding));
  return load(content, options);
});


/*
 * Read and parse YAML file
 * Note: Returns an instance of Promise unless callback given
 * 
 * @param int|string filename - File descriptor or path
 * @param null|object options
 * @param function cb
 */

read = function(filename, options, cb) {
  var ref4;
  if (options == null) {
    options = {};
  }
  if (cb == null) {
    cb = null;
  }
  if (typeof options === "function") {
    ref4 = [options, {}], cb = ref4[0], options = ref4[1];
  }
  return fulfill(cb, function() {
    return readYamlFile(filename, options);
  });
};


/*
 * Synchronous version of yaml.read
 * 
 * @return JSON
 */

readSync = function(filename, options) {
  var content;
  if (options == null) {
    options = {};
  }
  options = normalizeOptions(options);
  if (!isNumber(filename)) {
    filename = normalizePathSync(filename);
  }
  content = readFileSync(filename, options.encoding);
  content = load(content, options);
  return content;
};


/*
 * Write some content to YAML file with Promise
 *
 * @api private
 */

writeYamlFile = co.wrap(function*(filename, content, options) {
  if (options == null) {
    options = {};
  }
  if (!isNumber(filename)) {
    filename = (yield normalizePath(filename));
  }
  options = normalizeOptions(options);
  content = dump(content, options);
  yield writeFile(filename, content, options);
});


/*
 * Write some content to YAML file
 * Note: Returns an instance of Promise unless callback given
 *
 * @param int|string filename - File descriptor or path
 * @param object content - File content
 * @param object options
 * @param function cb
 */

write = function(filename, content, options, cb) {
  var ref4;
  if (options == null) {
    options = {};
  }
  if (cb == null) {
    cb = null;
  }
  if (typeof options === "function") {
    ref4 = [options, {}], cb = ref4[0], options = ref4[1];
  }
  return fulfill(cb, function() {
    return writeYamlFile(filename, content, options);
  });
};


/*
 * Synchronous version of yaml.write
 */

writeSync = function(filename, content, options) {
  if (options == null) {
    options = null;
  }
  filename = normalizePathSync(filename);
  options = normalizeOptions(options);
  content = dump(content);
  writeFileSync(filename, content, options.encoding || null);
};

module.exports = {
  Type: yaml.Type,
  createSchema: yaml.Schema.create,
  schema: PARSER_SCHEMA,
  parse: load,
  dump: dump,
  read: read,
  readSync: readSync,
  write: write,
  writeSync: writeSync
};

//# sourceMappingURL=main.js.map
